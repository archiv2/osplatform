<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CPU Scheduling Simulator - OS Platform</title>
  <style>
    :root{
      --bg:#000;--bg-2:#0a0a0a;--panel:#111;--panel-2:#131313;--line:#222;
      --text:#fff;--muted:#b9c2cc;--accent:#00bfff;--btn:#0078ff;--btn-hover:#005ec9;
      --good:#0ecb81;--warn:#ffcc00;--bad:#ff5c5c;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Arial,system-ui,-apple-system,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    /* header */
    header{
      position:sticky;top:0;z-index:20;
      display:flex;justify-content:space-between;align-items:center;
      padding:20px 60px;background:var(--bg-2);border-bottom:1px solid var(--line)
    }
    .logo{font-size:1.4em;font-weight:700;color:var(--accent)}
    nav{display:flex;align-items:center;gap:150px}
    .dropdown{
      position:relative;
      display:inline-block;
      padding:6px 0;
      cursor:pointer;
    }
    .dropdown::after{
      content:" ⌄";
      display:inline-block;
      font-size:.8em;
      color:#ccc;
      transition:transform .25s ease,color .25s ease;
    }
    .dropdown:hover::after{
      transform:rotate(180deg);
      color:var(--accent);
    }
    .dropdown-content{
      display:none;
      position:absolute;
      background:#111;
      min-width:180px;
      box-shadow:0 8px 16px rgba(0,0,0,.3);
      z-index:10;
    }
    .dropdown-content a{
      color:#fff;
      padding:10px 14px;
      text-decoration:none;
      display:block;
    }
    .dropdown-content a:hover{background:#333}
    .dropdown:hover .dropdown-content{display:block}
    .dropdown > span > a{
      color:#fff;
      text-decoration:none;
    }
    .actions{display:flex;align-items:center;gap:20px}
    .login-btn{
      background:var(--btn);color:#fff;border:none;padding:8px 16px;
      border-radius:20px;cursor:pointer;font-weight:700
    }
    .login-btn:hover{background:var(--btn-hover)}
    .profile-btn{
      background:transparent;border:none;padding:0;cursor:pointer;
      line-height:0;border-radius:999px;outline:none
    }
    .profile-btn svg{
      width:36px;height:36px;
      background:#fff;border-radius:999px;padding:4px
    }
    .profile-btn:hover svg{
      box-shadow:0 0 0 3px rgba(0,191,255,.25)
    }
    @media (max-width:880px){
      header{padding:16px 20px;flex-wrap:wrap;gap:12px}
      nav{gap:40px}
    }

    .wrap{
      max-width:1150px;
      margin:0 auto;
      padding:40px 24px 120px;
      overflow-x:hidden;
    }
    .eyebrow{
      font-size:.9rem;
      letter-spacing:.12em;
      color:var(--muted);
      text-transform:uppercase
    }
    h1{
      margin:.25rem 0 0;
      font-size:2.1rem;
      line-height:1.2;
    }
    .lead{
      margin-top:12px;
      color:#d7e2ea;
      line-height:1.7;
      font-size:.96rem;
    }

    .sim-layout{
      display:grid;
      grid-template-columns:minmax(0,1.35fr) minmax(0,1fr);
      gap:20px;
      margin-top:26px;
      align-items:flex-start;
    }
    @media (max-width:960px){
      .sim-layout{grid-template-columns:1fr}
    }

    .panel{
      background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);
      border:1px solid var(--line);
      border-radius:16px;
      padding:18px 20px 20px;
    }
    .panel-title{
      font-size:1rem;
      font-weight:600;
      margin-bottom:6px;
    }
    .panel-sub{
      font-size:.86rem;
      color:var(--muted);
      margin-bottom:14px;
    }

    .control-row{
      display:flex;
      flex-wrap:wrap;
      gap:12px 16px;
      margin-bottom:12px;
      align-items:flex-end;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:.85rem;
    }
    .field label{color:#c8d3dc}
    select,input[type="number"],input[type="text"]{
      background:#050506;
      color:var(--text);
      border-radius:10px;
      border:1px solid var(--line);
      padding:6px 8px;
      font-size:.86rem;
      min-width:90px;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{
      -webkit-appearance:none;
      margin:0;
    }

    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:6px;
      margin-bottom:4px;
    }
    .btn{
      border-radius:999px;
      border:1px solid var(--line);
      padding:7px 14px;
      font-size:.85rem;
      cursor:pointer;
      background:#141820;
      color:#dbe7f5;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .btn-primary{
      background:var(--btn);
      color:#fff;
      border-color:transparent;
    }
    .btn-primary:hover{background:var(--btn-hover)}
    .btn-danger{
      background:#1b1010;
      color:#ffb3b3;
      border-color:#442020;
    }
    .btn:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }

    .proc-table{
      width:100%;
      border-collapse:collapse;
      margin-top:10px;
      font-size:.86rem;
    }
    .proc-table th,
    .proc-table td{
      border:1px solid var(--line);
      padding:6px 8px;
      text-align:center;
    }
    .proc-table th{
      background:#111319;
      color:#dbe9f5;
      font-weight:500;
    }
    .pid-cell{
      font-weight:600;
      color:#e6f7ff;
      white-space:nowrap;
    }
    .empty-row{
      font-size:.83rem;
      color:#7d8795;
      text-align:center;
    }

    .howto-list{
      list-style:none;
      padding:0;
      margin:0;
      font-size:.87rem;
      color:#c8d3dc;
    }
    .howto-list li+li{margin-top:6px}
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:.78rem;
      padding:3px 8px;
      line-height:1;
      border-radius:999px;
      border:1px solid var(--line);
      color:#9cc7ff;
      background:#0b1a2a;
      vertical-align:middle;
      margin-right:4px;
    }
    .note-box{
      margin-top:12px;
      padding:10px 12px;
      border-radius:10px;
      border:1px dashed #33495f;
      background:#070a10;
      color:#9bb3c7;
      font-size:.82rem;
    }

    hr.sep{
      border:none;
      border-top:1px solid var(--line);
      margin:30px 0 24px;
      opacity:.6;
    }

    /* 차트 박스 바깥 테두리 */
    .chart-area{
      margin-top:4px;
      margin-bottom:10px;
      padding:10px 12px 12px;
      border-radius:14px;
      border:1px dashed var(--line);
      background:#05070c;
    }

    .metrics-grid{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:10px;
      margin-top:6px;
      margin-bottom:12px;
    }
    @media (max-width:900px){
      .metrics-grid{grid-template-columns:repeat(2,1fr)}
    }
    @media (max-width:520px){
      .metrics-grid{grid-template-columns:1fr}
    }
    .metric-card{
      border-radius:12px;
      border:1px solid var(--line);
      background:#0c1018;
      padding:8px 10px 9px;
      font-size:.8rem;
    }
    .metric-label{color:#9bb3c7;margin-bottom:3px}
    .metric-value{
      font-size:1rem;
      font-weight:600;
    }
    .metric-unit{font-size:.78rem;color:#7e8a99;margin-left:4px}

    .result-table{
      width:100%;
      border-collapse:collapse;
      font-size:.84rem;
      margin-top:4px;
    }
    .result-table th,
    .result-table td{
      border:1px solid var(--line);
      padding:5px 6px;
      text-align:center;
    }
    .result-table th{
      background:#111319;
      color:#dbe9f5;
    }
    .result-placeholder{
      font-size:.83rem;
      color:#7d8795;
      text-align:center;
    }

    /* ===== Gantt Chart 스타일 ===== */
    .gantt-chart{
      width:100%;
      background:radial-gradient(circle at 10% 0%, #001a33, #020308 65%);
      border-radius:12px;
      border:1px solid var(--line);
      padding:10px 14px;
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:.8rem;
      color:#dbe9ff;
    }
    .gantt-chart-empty{
      display:flex;
      align-items:center;
      justify-content:center;
      height:100%;
      text-align:center;
      color:#7c8aa0;
    }
    .gantt-row{
      display:flex;
      align-items:stretch;
      width:100%;
      overflow:hidden;
      border-radius:10px;
      background:#020308;
    }
    .gantt-block{
      position:relative;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:4px 0;
      white-space:nowrap;
    }
    .gantt-block:not(:last-child){
      box-shadow:inset -1px 0 0 rgba(0,0,0,.45);
    }
    .gantt-pid{
      font-weight:600;
    }

    .gantt-time-row{
      display:flex;
      width:100%;
      margin-top:6px;
      font-size:.75rem;
      color:#9bb3c7;
    }
    .gantt-time-label{
      text-align:center;
    }

    .gantt-caption{
      margin-top:6px;
      font-size:.78rem;
      color:#9bb3c7;
      line-height:1.5;
    }
  </style>
</head>
<body>
<header>
  <a href="/index.html" class="logo">OS Platform</a>

  <nav>
    <!-- Learn -->
    <div class="dropdown">
      <span>Learn</span>
      <div class="dropdown-content">
        <a href="/learn-scheduling.html">CPU Scheduling</a>
        <a href="/learn-paging.html">Page Replacement</a>
        <a href="/learn-deadlock.html">Deadlock</a>
      </div>
    </div>

    <!-- Simulator -->
    <div class="dropdown">
      <span>Simulator</span>
      <div class="dropdown-content">
        <a href="/sim-scheduling.html">CPU Scheduling Simulator</a>
        <a href="/sim-paging.html">Page Replacement Simulator</a>
        <a href="/sim-deadlock.html">Deadlock Simulator</a>
      </div>
    </div>

    <!-- Compare -->
    <div class="dropdown">
      <span>Compare</span>
      <div class="dropdown-content">
        <a href="/compare-scheduling.html">Scheduling Algorithms Compare</a>
        <a href="/compare-paging.html">Paging Algorithms Compare</a>
      </div>
    </div>
  </nav>

  <div class="actions">
    <div id="authArea"></div>
  </div>
</header>

<div class="wrap">
  <div class="eyebrow">SIM / CPU Scheduling</div>
  <h1>CPU Scheduling Simulator</h1>
  <p class="lead">
    알고리즘과 프로세스 목록을 설정한 뒤, 시뮬레이션을 실행하면<br />
    Gantt 차트와 함께 <b>평균 WT / TAT / RT, Throughput</b>까지 한눈에 볼 수 있도록 설계된 페이지입니다.
  </p>

  <div class="sim-layout">
    <!-- 설정 -->
    <section class="panel" aria-label="시뮬레이션 설정">
      <div class="panel-title">시뮬레이션 설정</div>
      <div class="panel-sub">
        알고리즘과 시간 단위를 선택한 뒤, 프로세스를 추가하고 <b>시뮬레이션 실행</b>을 눌러보세요.
      </div>

      <div class="control-row">
        <div class="field">
          <label for="algo-select">알고리즘 선택</label>
          <select id="algo-select">
            <option value="FCFS">FCFS (First Come First Served)</option>
            <option value="SJF">SJF (Shortest Job First)</option>
            <option value="RR">RR (Round Robin)</option>
            <option value="SRT">SRT (Shortest Remaining Time)</option>
          </select>
        </div>

        <div class="field">
          <label for="time-unit">시간 단위</label>
          <select id="time-unit">
            <option value="sec">초 (seconds)</option>
            <option value="ms">밀리초 (milliseconds)</option>
          </select>
        </div>

        <div class="field" id="quantum-field" style="display:none;">
          <label for="time-quantum">Time Quantum (RR 전용)</label>
          <input type="number" id="time-quantum" min="1" value="4" />
        </div>
      </div>

      <div class="btn-row">
        <button type="button" class="btn" id="add-proc-btn">+ 프로세스 추가</button>
        <button type="button" class="btn btn-danger" id="reset-btn">초기화</button>
        <button type="button" class="btn btn-primary" id="run-btn">시뮬레이션 실행</button>
      </div>

      <table class="proc-table" aria-label="프로세스 목록">
        <thead>
        <tr>
          <th style="width:70px;">PID</th>
          <th style="width:110px;">도착 시간 (Arrival)</th>
          <th style="width:110px;">버스트 시간 (Burst)</th>
        </tr>
        </thead>
        <tbody id="proc-body">
        <!-- JS에서 P1부터 추가 -->
        </tbody>
      </table>
    </section>

    <!-- 사용법 -->
    <aside class="panel" aria-label="사용 방법">
      <div class="panel-title">사용 방법 &amp; 팁</div>
      <div class="panel-sub">
        입력은 단순하게, 결과는 직관적으로 볼 수 있도록 구성했습니다.
      </div>
      <ul class="howto-list">
        <li>
          <span class="badge">1</span>
          사용할 <b>스케줄링 알고리즘</b>과 <b>시간 단위</b>를 선택합니다.
        </li>
        <li>
          <span class="badge">2</span>
          <b>프로세스 추가</b> 버튼을 눌러 P1, P2, P3... 순서대로
          <b>도착 시간 / 버스트 시간</b>을 입력합니다.
        </li>
        <li>
          <span class="badge">3</span>
          설정을 모두 마쳤다면 <b>시뮬레이션 실행</b>을 눌러
          아래의 <b>Gantt 차트 / 지표 / 프로세스별 결과</b>를 확인합니다.
        </li>
        <li>
          <span class="badge">4</span>
          다른 케이스를 보고 싶다면 <b>초기화</b>로 목록을 지우고
          새로운 프로세스 세트를 넣어 다시 실행할 수 있습니다.
        </li>
      </ul>

      <div class="note-box">
        현재는 프론트 입력을 받아 <b>백엔드 스케줄링 API</b>에 요청을 보내
        WT / TAT / RT 등을 계산합니다.
      </div>
    </aside>
  </div>

  <hr class="sep" />

  <!-- 결과 영역 -->
  <section class="panel" aria-label="시뮬레이션 결과">
    <div class="panel-title">시뮬레이션 결과</div>
    <div class="panel-sub">
      위 설정으로 실행한 결과가 이 영역에 표시됩니다. Gantt 차트, 핵심 지표, 프로세스별 시간 정보를 한 번에 확인하세요.
    </div>

    <div class="chart-area">
      <div id="gantt-chart" class="gantt-chart">
        시뮬레이션을 실행해 주세요.<br>
        실행 후 이 영역에 Gantt Chart / 타임라인 시각화가 표시됩니다.
      </div>
      <div id="gantt-caption" class="gantt-caption">
        프로세스 실행 순서와 각 구간의 시간 범위를 한눈에 보여주는 Gantt 차트입니다.
      </div>
    </div>

    <div class="metrics-grid">
      <div class="metric-card">
        <div class="metric-label">평균 대기 시간 (Avg WT)</div>
        <div><span class="metric-value" id="avg-wt">–</span><span class="metric-unit" id="wt-unit"></span></div>
      </div>
      <div class="metric-card">
        <div class="metric-label">평균 반환 시간 (Avg TAT)</div>
        <div><span class="metric-value" id="avg-tat">–</span><span class="metric-unit" id="tat-unit"></span></div>
      </div>
      <div class="metric-card">
        <div class="metric-label">평균 응답 시간 (Avg RT)</div>
        <div><span class="metric-value" id="avg-rt">–</span><span class="metric-unit" id="rt-unit"></span></div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Throughput (단위 시간당 완료 수)</div>
        <div><span class="metric-value" id="throughput">–</span><span class="metric-unit">proc / unit</span></div>
      </div>
    </div>

    <div class="btn-row" style="margin: 14px 0 4px; gap: 8px">
      <button type="button" class="btn" id="save-scheduling-record-btn">
        결과 저장하기
      </button>
    </div>

    <table class="result-table" aria-label="프로세스별 시뮬레이션 결과">
      <thead>
      <tr>
        <th>PID</th>
        <th>도착 시간</th>
        <th>버스트 시간</th>
        <th>시작 시각</th>
        <th>완료 시각</th>
        <th>대기 시간 (WT)</th>
        <th>반환 시간 (TAT)</th>
        <th>응답 시간 (RT)</th>
      </tr>
      </thead>
      <tbody id="result-body">
      <tr>
        <td colspan="8" class="result-placeholder">
          시뮬레이션을 실행하면 여기에서 각 프로세스의 시간 정보를 확인할 수 있습니다.
        </td>
      </tr>
      </tbody>
    </table>
  </section>
</div>

<script>
  let lastSchedulingResult = null;
  let procCount = 0;

  // --- Gantt Chart 렌더링 함수 (막대 안에는 PID만, 아래 줄에 시간) ---
  function renderGanttChart(gantt) {
    const container = document.getElementById('gantt-chart');
    if (!container) return;

    container.innerHTML = '';

    if (!gantt || gantt.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'gantt-chart-empty';
      empty.innerHTML = '시뮬레이션 결과가 없습니다.<br>프로세스를 추가하고 실행을 눌러주세요.';
      container.appendChild(empty);
      return;
    }

    // 전체 시간 = end의 최댓값
    const totalTime = gantt.reduce((max, seg) => Math.max(max, seg.end || 0), 0);
    if (!totalTime) {
      container.textContent = '유효한 Gantt 데이터가 없습니다.';
      return;
    }

    const colorMap = {};
    const palette = ['#4fd1c5','#63b3ed','#f6ad55','#fc8181','#9f7aea','#f687b3','#48bb78','#fbd38d'];
    const getColor = (pid) => {
      if (!colorMap[pid]) {
        colorMap[pid] = palette[Object.keys(colorMap).length % palette.length];
      }
      return colorMap[pid];
    };

    const row = document.createElement('div');
    row.className = 'gantt-row';

    const timeRow = document.createElement('div');
    timeRow.className = 'gantt-time-row';

    gantt.forEach(seg => {
      const len = (seg.end ?? 0) - (seg.start ?? 0);
      if (len <= 0) return;

      const widthPercent = (len / totalTime) * 100;

      // 막대 (PID만 표시)
      const block = document.createElement('div');
      block.className = 'gantt-block';
      block.style.flexBasis = widthPercent + '%';
      block.style.backgroundColor = getColor(seg.pid);

      const pidSpan = document.createElement('span');
      pidSpan.className = 'gantt-pid';
      pidSpan.textContent = seg.pid;
      block.appendChild(pidSpan);
      row.appendChild(block);

      // 아래 시간 라벨
      const timeLabel = document.createElement('div');
      timeLabel.className = 'gantt-time-label';
      timeLabel.style.flexBasis = widthPercent + '%';
      timeLabel.textContent = `${seg.start}~${seg.end}`;
      timeRow.appendChild(timeLabel);
    });

    container.appendChild(row);
    container.appendChild(timeRow);
  }

  // --- Gantt 캡션 업데이트 ---
  function updateGanttCaption(gantt, algo, unitText) {
    const caption = document.getElementById('gantt-caption');
    if (!caption) return;

    if (!gantt || !gantt.length) {
      caption.textContent =
        '프로세스 실행 순서와 각 구간의 시간 범위를 한눈에 보여주는 Gantt 차트입니다.';
      return;
    }

    const order = gantt.map(s => s.pid).join(' → ');
    const totalTime = gantt.reduce((max, seg) => Math.max(max, seg.end || 0), 0);

    caption.textContent =
      `알고리즘 ${algo} 기준 실행 순서: ${order} (총 실행 시간: ${totalTime}${unitText}). ` +
      `막대 길이는 각 프로세스가 CPU를 점유한 시간 비율을 의미합니다.`;
  }

  // --- 프로세스 추가/초기화 로직 ---
  function createProcRow(pidLabel, arrival = 0, burst = 1) {
    const tbody = document.getElementById('proc-body');

    const placeholder = tbody.querySelector('.empty-row');
    if (placeholder) placeholder.remove();

    const tr = document.createElement('tr');

    const tdPid = document.createElement('td');
    tdPid.className = 'pid-cell';
    tdPid.textContent = pidLabel;

    const tdArr = document.createElement('td');
    const inputArr = document.createElement('input');
    inputArr.type = 'number';
    inputArr.min = '0';
    inputArr.step = '1';
    inputArr.value = arrival;
    inputArr.setAttribute('aria-label', pidLabel + ' 도착 시간');
    tdArr.appendChild(inputArr);

    const tdBurst = document.createElement('td');
    const inputBurst = document.createElement('input');
    inputBurst.type = 'number';
    inputBurst.min = '1';
    inputBurst.step = '1';
    inputBurst.value = burst;
    inputBurst.setAttribute('aria-label', pidLabel + ' 버스트 시간');
    tdBurst.appendChild(inputBurst);

    tr.appendChild(tdPid);
    tr.appendChild(tdArr);
    tr.appendChild(tdBurst);

    tbody.appendChild(tr);
  }

  function addProcess() {
    procCount += 1;
    const pidLabel = 'P' + procCount;
    createProcRow(pidLabel);
  }

  function resetSim() {
    const tbody = document.getElementById('proc-body');
    tbody.innerHTML = '';
    procCount = 0;
    addProcess(); // 기본 P1 한 줄

    // 지표 리셋
    document.getElementById('avg-wt').textContent = '–';
    document.getElementById('avg-tat').textContent = '–';
    document.getElementById('avg-rt').textContent = '–';
    document.getElementById('throughput').textContent = '–';
    document.getElementById('wt-unit').textContent = '';
    document.getElementById('tat-unit').textContent = '';
    document.getElementById('rt-unit').textContent = '';
    document.getElementById('result-body').innerHTML =
      '<tr><td colspan="8" class="result-placeholder">시뮬레이션을 실행하면 여기에서 각 프로세스의 시간 정보를 확인할 수 있습니다.</td></tr>';

    const chartBox = document.getElementById('gantt-chart');
    if (chartBox) {
      chartBox.innerHTML =
        '시뮬레이션을 실행해 주세요.<br>' +
        '실행 후 이 영역에 Gantt Chart / 타임라인 시각화가 표시됩니다.';
    }
    const caption = document.getElementById('gantt-caption');
    if (caption) {
      caption.textContent =
        '프로세스 실행 순서와 각 구간의 시간 범위를 한눈에 보여주는 Gantt 차트입니다.';
    }

    lastSchedulingResult = null;
  }

  // --- 백엔드 연동 시뮬레이션 실행 ---
  async function runSimulation() {
    const algo = document.getElementById('algo-select').value;   // FCFS / RR / ...
    const timeUnit = document.getElementById('time-unit').value; // sec/ms (표시용)
    const unitText = (timeUnit === 'ms') ? ' ms' : ' sec';

    const tbody = document.getElementById('proc-body');
    const rows = Array.from(tbody.querySelectorAll('tr'));

    // 1) 화면에서 프로세스 입력값 수집
    const processes = [];
    rows.forEach((row, idx) => {
      const pid = row.querySelector('.pid-cell')?.textContent?.trim() || `P${idx + 1}`;
      const inputs = row.querySelectorAll('input');
      if (inputs.length < 2) return;

      const arrival = parseInt(inputs[0].value, 10);
      const burst = parseInt(inputs[1].value, 10);

      if (!Number.isNaN(arrival) && !Number.isNaN(burst) && burst > 0) {
        processes.push({ pid, arrival, burst });
      }
    });

    if (processes.length === 0) {
      alert('프로세스를 한 개 이상 입력해주세요.');
      return;
    }

    // RR일 때만 time quantum 사용
    let quantum = null;
    if (algo === 'RR') {
      const q = parseInt(document.getElementById('time-quantum').value, 10);
      quantum = (!q || q <= 0) ? 1 : q;
    }

    try {
      // 2) 백엔드로 요청 보내기
      const res = await fetch('/api/sim/scheduling', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ algo, quantum, processes })
      });

      if (!res.ok) {
        throw new Error('서버 오류: ' + res.status);
      }

      const data = await res.json();
      const gantt = data.gantt || [];
      const metrics = data.metrics || [];

      // 3) Gantt 결과로 각 프로세스의 start/finish/WT/TAT/RT 계산
      const firstStart = {};
      const endTime = {};

      gantt.forEach(slot => {
        const pid = slot.pid;
        const start = slot.start;
        const end = slot.end;

        if (!(pid in firstStart) || start < firstStart[pid]) {
          firstStart[pid] = start;
        }
        endTime[pid] = Math.max(endTime[pid] ?? 0, end);
      });

      const detailedProcs = processes.map(p => {
        const fs = firstStart[p.pid] ?? 0;
        const e = endTime[p.pid] ?? fs;
        const turnaround = e - p.arrival;
        const waiting = turnaround - p.burst;
        const response = fs - p.arrival;
        return {
          ...p,
          start: fs,
          finish: e,
          wait: waiting,
          turnaround,
          response
        };
      });

      // 총 실행 시간 = gantt에서 가장 큰 end
      const totalTime = gantt.reduce((max, s) => Math.max(max, s.end || 0), 0);

      // 평균값: 백엔드가 준 metrics 우선 사용
      const avgWT = (metrics.avgWaiting !== undefined)
        ? metrics.avgWaiting
        : detailedProcs.reduce((sum, p) => sum + p.wait, 0) / detailedProcs.length;

      const avgTAT = (metrics.avgTurnaround !== undefined)
        ? metrics.avgTurnaround
        : detailedProcs.reduce((sum, p) => sum + p.turnaround, 0) / detailedProcs.length;

      const avgRT = (metrics.avgResponse !== undefined)
        ? metrics.avgResponse
        : detailedProcs.reduce((sum, p) => sum + p.response, 0) / detailedProcs.length;

      const throughput = (detailedProcs.length / (totalTime || 1)).toFixed(3);

      // ✅ Gantt 차트 + 캡션 업데이트
      renderGanttChart(gantt);
      updateGanttCaption(gantt, algo, unitText);

      // 4) 상단 요약 영역 업데이트
      document.getElementById('wt-unit').textContent = unitText;
      document.getElementById('tat-unit').textContent = unitText;
      document.getElementById('rt-unit').textContent = unitText;
      document.getElementById('avg-wt').textContent = Number(avgWT).toFixed(2);
      document.getElementById('avg-tat').textContent = Number(avgTAT).toFixed(2);
      document.getElementById('avg-rt').textContent = Number(avgRT).toFixed(2);
      document.getElementById('throughput').textContent = throughput;

      // 5) 프로세스별 결과 테이블 채우기
      const resultBody = document.getElementById('result-body');
      resultBody.innerHTML = '';
      detailedProcs.forEach(p => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${p.pid}</td>
          <td>${p.arrival}</td>
          <td>${p.burst}</td>
          <td>${p.start}</td>
          <td>${p.finish}</td>
          <td>${p.wait}</td>
          <td>${p.turnaround}</td>
          <td>${p.response}</td>
        `;
        resultBody.appendChild(tr);
      });

      // 저장용 데이터
      lastSchedulingResult = {
        type: 'scheduling',
        title: `CPU Scheduling (${algo}${algo === 'RR' ? `, Q=${quantum}` : ''})`,
        algo,
        quantum,
        timeUnit,
        totalTime,
        metrics: {
          avgWT: Number(avgWT),
          avgTAT: Number(avgTAT),
          avgRT: Number(avgRT),
          throughput: Number(throughput)
        },
        processes: detailedProcs
      };

    } catch (err) {
      console.error(err);
      alert('시뮬레이션 중 오류가 발생했습니다.');
    }
  }

  // --- 알고리즘별 Time Quantum 필드 토글 ---
  function handleAlgoChange() {
    const algo = document.getElementById('algo-select').value;
    const qField = document.getElementById('quantum-field');
    qField.style.display = (algo === 'RR') ? 'flex' : 'none';
  }

  // --- 리액트(3000)에서 8080으로 링크 강제 ---
  (function () {
    if (location.port === '3000') {
      document.querySelectorAll('.dropdown-content a').forEach(a => {
        const href = a.getAttribute('href');
        if (href && href.startsWith('/')) {
          a.addEventListener('click', function (e) {
            e.preventDefault();
            window.location.assign('http://localhost:8080' + href);
          });
        }
      });
    }
  })();

  // --- 결과 저장 ---
  async function saveSchedulingRecord() {
    if (!lastSchedulingResult) {
      alert('먼저 시뮬레이션을 실행해주세요.');
      return;
    }

    // 혹시 모를 비로그인 접근 방지
    const user = sessionStorage.getItem('user');
    if (!user || user.trim() === '') {
      alert('로그인이 필요한 서비스입니다.');
      window.location.href = 'login.html';
      return;
    }

    try {
      const res = await fetch('/api/records', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(lastSchedulingResult)
      });

      if (!res.ok) {
        throw new Error('status ' + res.status);
      }

      alert('저장하였습니다. 마이페이지에서 확인하세요.');
    } catch (e) {
      console.error(e);
      alert('저장 중 오류가 발생했습니다.');
    }
  }

  // --- 초기 세팅: 로그인 체크 + 헤더 버튼 + 이벤트 ---
  document.addEventListener('DOMContentLoaded', () => {
    const user = sessionStorage.getItem('user');

    // 로그인 안 되어 있으면 시뮬레이터 진입 불가
    if (!user || user.trim() === '') {
      alert('로그인이 필요한 서비스입니다.');
      window.location.href = 'login.html';
      return;
    }

    // 헤더 프로필 버튼 세팅
    const container = document.getElementById('authArea');
    if (container) {
      container.innerHTML = `
        <button class="profile-btn" aria-label="My Page" title="My Page" onclick="location.href='mypage.html'">
          <svg viewBox="0 0 24 24" fill="black" xmlns="http://www.w3.org/2000/svg">
            <circle cx="12" cy="8" r="4"></circle>
            <path d="M4 20c0-4 4-6 8-6s8 2 8 6"></path>
          </svg>
        </button>
      `;
    }

    // 버튼 이벤트 & 기본 상태
    document.getElementById('add-proc-btn').addEventListener('click', addProcess);
    document.getElementById('reset-btn').addEventListener('click', resetSim);
    document.getElementById('run-btn').addEventListener('click', runSimulation);
    document.getElementById('algo-select').addEventListener('change', handleAlgoChange);
    document.getElementById('save-scheduling-record-btn')
      .addEventListener('click', saveSchedulingRecord);

    resetSim();
    handleAlgoChange();
  });
</script>
</body>
</html>
