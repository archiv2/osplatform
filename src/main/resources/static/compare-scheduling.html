<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Compare | CPU 스케줄링 - OS Platform</title>
  <style>
    :root{
      --bg:#000;--bg-2:#0a0a0a;--panel:#111;--panel-2:#131313;--line:#222;
      --text:#fff;--muted:#b9c2cc;--accent:#00bfff;--btn:#0078ff;--btn-hover:#005ec9;
      --good:#0ecb81;--warn:#ffcc00;--bad:#ff5c5c;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Arial,system-ui,-apple-system,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    /* header – Learn 페이지와 동일한 드롭다운 스타일 */
    header{
      position:sticky;top:0;z-index:20;
      display:flex;justify-content:space-between;align-items:center;
      padding:20px 60px;background:var(--bg-2);border-bottom:1px solid var(--line)
    }
    .logo{font-size:1.4em;font-weight:700;color:var(--accent)}
    nav{display:flex;align-items:center;gap:150px}
    .dropdown{position:relative;display:inline-block;padding:6px 0;cursor:pointer}
    .dropdown::after{
      content:" ⌄";display:inline-block;font-size:.8em;color:#ccc;
      transition:transform .25s ease,color .25s ease
    }
    .dropdown:hover::after{transform:rotate(180deg);color:var(--accent)}
    .dropdown-content{
      display:none;position:absolute;background:#111;min-width:180px;
      box-shadow:0 8px 16px rgba(0,0,0,.3);z-index:10
    }
    .dropdown-content a{
      color:#fff;padding:10px 14px;text-decoration:none;display:block
    }
    .dropdown-content a:hover{background:#333}
    .dropdown:hover .dropdown-content{display:block}
    .dropdown > span > a{color:#fff;text-decoration:none}
    .actions{display:flex;align-items:center;gap:20px}
    #authArea{}
    @media (max-width:880px){
      header{padding:16px 20px;flex-wrap:wrap;gap:12px}
      nav{gap:40px}
    }

    /* 본문 레이아웃 */
    main{max-width:1120px;margin:0 auto;padding:26px 20px 60px}

    h1{font-size:1.8rem;margin:4px 0 8px}
    .subtitle{color:var(--muted);font-size:.95rem;margin-bottom:20px}

    .pill-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:18px}
    .pill{
      border-radius:999px;border:1px solid var(--line);
      padding:4px 10px;font-size:.8rem;color:var(--muted);
      display:inline-flex;align-items:center;gap:4px;
    }
    .pill span.dot{
      width:7px;height:7px;border-radius:50%;background:var(--accent);
    }

    .panel{
      background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);
      border:1px solid var(--line);
      border-radius:16px;
      padding:18px 20px 18px;
      margin-bottom:18px;
    }
    .panel h2{
      font-size:1.15rem;
      margin:0 0 6px;
    }
    .panel .sub{
      font-size:.9rem;color:var(--muted);margin:0 0 12px;
    }

    /* 상단 고정 비교표 */
    .alg-table{
      width:100%;
      border-collapse:collapse;
      font-size:.9rem;
    }
    .alg-table thead{
      background:rgba(255,255,255,.02);
    }
    .alg-table th,
    .alg-table td{
      border:1px solid var(--line);
      padding:8px 10px;
      vertical-align:top;
    }
    .alg-table th{
      text-align:left;
      font-size:.85rem;
      color:#dbe9f5;
    }
    .alg-col-name{
      font-weight:600;
      color:#e6f7ff;
      white-space:nowrap;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      padding:2px 8px;
      border-radius:999px;
      font-size:.75rem;
      border:1px solid var(--line);
      color:var(--muted);
      margin-right:4px;
      margin-bottom:3px;
    }
    .tag.preempt{border-color:var(--accent);color:var(--accent)}
    .tag.nonpreempt{border-color:#888;color:#cdd6e0}
    .tag-good{color:var(--good)}
    .tag-warn{color:var(--warn)}
    .tag-bad{color:var(--bad)}

    /* 하단 직접 비교 영역 */
    .section-title{
      margin:26px 0 8px;
      font-size:1.25rem;
    }
    .section-desc{
      margin:0 0 14px;
      font-size:.92rem;
      color:var(--muted);
    }

    .scenario-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:16px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .scenario-row-left{display:flex;align-items:center;gap:10px;font-size:.9rem;color:var(--muted)}
    select{
      background:#050506;
      color:var(--text);
      border-radius:10px;
      border:1px solid var(--line);
      padding:6px 10px;
      font-size:.88rem;
      min-width:130px;
    }

    .compare-grid{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:16px;
      margin-top:6px;
    }
    .compare-card{
      background:linear-gradient(180deg,#0e0e0e 0%,#101018 100%);
      border-radius:16px;
      border:1px solid var(--line);
      padding:14px 16px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .compare-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .compare-title{
      font-size:.95rem;
      font-weight:600;
    }
    .compare-meta{
      font-size:.8rem;color:var(--muted);
    }
    .mini-label{font-size:.78rem;color:var(--muted);margin-bottom:3px}

    .metric-table{
      width:100%;
      border-collapse:collapse;
      font-size:.83rem;
      margin-top:2px;
    }
    .metric-table th,
    .metric-table td{
      border:1px solid var(--line);
      padding:5px 6px;
    }
    .metric-table th{
      text-align:left;
      color:#dbe9f5;
      width:40%;
    }
    .metric-table td.placeholder{
      color:#6f7b88;
      font-style:italic;
    }

    .gantt-box{
      border-radius:10px;
      border:1px dashed var(--line);
      padding:10px;
      font-size:.8rem;
      color:#778495;
      text-align:center;
    }

    .compare-note{
      margin-top:12px;
      font-size:.84rem;
      color:var(--muted);
      border-top:1px dashed var(--line);
      padding-top:10px;
    }

    .comment-panel{
      margin-top:14px;
      padding:10px 12px;
      border-radius:10px;
      border:1px dashed var(--line);
      font-size:.86rem;
      color:var(--muted);
    }
    .comment-panel span{
      color:var(--accent);
    }

    .btn-row{
      display:flex;
      gap:8px;
      margin-top:10px;
      justify-content:flex-end;
    }
    .btn{
      border:none;
      border-radius:999px;
      padding:8px 16px;
      font-size:.9rem;
      cursor:pointer;
      background:var(--btn);
      color:#fff;
    }
    .btn:hover{
      background:var(--btn-hover);
    }

    @media(max-width:900px){
      main{padding:22px 16px 50px}
      .compare-grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
<header>
  <a href="/index.html" class="logo">OS Platform</a>

  <nav>
    <!-- Learn -->
    <div class="dropdown">
      <span>Learn</span>
      <div class="dropdown-content">
        <a href="/learn-scheduling.html">CPU Scheduling</a>
        <a href="/learn-paging.html">Page Replacement</a>
        <a href="/learn-deadlock.html">Deadlock</a>
      </div>
    </div>

    <!-- Simulator -->
    <div class="dropdown">
      <span>Simulator</span>
      <div class="dropdown-content">
        <a href="/sim-scheduling.html">CPU Scheduling Simulator</a>
        <a href="/sim-paging.html">Page Replacement Simulator</a>
        <a href="/sim-deadlock.html">Deadlock Simulator</a>
      </div>
    </div>

    <!-- Compare -->
    <div class="dropdown">
      <span>Compare</span>
      <div class="dropdown-content">
        <a href="/compare-scheduling.html">Scheduling Algorithms Compare</a>
        <a href="/compare-paging.html">Paging Algorithms Compare</a>
      </div>
    </div>
  </nav>

  <div class="actions">
    <div id="authArea"></div>
  </div>
</header>

<main>
  <h1>CPU Scheduling Algorithm Compare</h1>
  <p class="subtitle">
    알고리즘 4개를 한눈에 비교해서 보거나,<br />
    원하는 알고리즘을 선택해 시나리오별 알고리즘 결과를 비교할 수 있습니다.
  </p>

  <!-- 상단 고정 비교표 -->
  <section class="panel">
    <h2>알고리즘 한눈에 보기</h2>
    <p class="sub">
      입력 시나리오와 상관없이 변하지 않는 알고리즘 4가지 핵심 차이
    </p>

    <table class="alg-table">
      <thead>
      <tr>
        <th style="width:110px">Algorithm</th>
        <th style="width:110px">Preemptive 여부</th>
        <th>스케줄링 기준</th>
        <th>요구 정보</th>
        <th>장점</th>
        <th>단점 / 기아 위험</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td class="alg-col-name">FCFS</td>
        <td>
          <span class="tag nonpreempt">Non-preemptive</span>
        </td>
        <td>
          도착 순서대로 CPU를 배분하는 방식
        </td>
        <td>
          <span class="tag">도착 시간(Arrival)</span>
        </td>
        <td>
          구현이 매우 단순하며, 도착 순서 기반이라 <span class="tag-good">기아(starvation)가 발생하지 않음.</span>
        </td>
        <td>
          긴 작업이 앞에 있으면 전체 응답성이 크게 저하되며,
          짧은 작업이 뒤로 밀리는 <span class="tag-warn">Convoy effect</span>가 발생
        </td>
      </tr>

      <tr>
        <td class="alg-col-name">SJF</td>
        <td>
          <span class="tag nonpreempt">Non-preemptive</span>
        </td>
        <td>
          예상 CPU Burst Time이 가장 짧은 프로세스를 우선 실행하는 방식
        </td>
        <td>
          <span class="tag">CPU burst 길이 추정</span>
        </td>
        <td>
          이론적으로 평균 대기시간, 평균 반환시간이 매우 우수하며,
          짧은 작업이 빠르게 처리되어 <span class="tag-good">일반적인 체감 성능이 좋음</span>.
        </td>
        <td>
          긴 작업은 계속 밀려 <span class="tag-warn">기아 가능성</span>이 있으며,<br/>
          실제 시스템에서는 burst 시간을 정확히 알기 어려움(추정 필요)
        </td>
      </tr>

      <tr>
        <td class="alg-col-name">Priority</td>
        <td>
          <span class="tag nonpreempt">Non-preemptive</span>
          <span class="tag preempt" style="margin-top:3px">Preemptive 버전도 존재</span>
        </td>
        <td>
          각 프로세스에 부여된 우선순위 값을 기준으로 CPU를 배분
        </td>
        <td>
          <span class="tag">Priority 값</span>
          <span class="tag">선점 여부 설정</span>
        </td>
        <td>
          중요한 작업에 우선순위를 배분하여 <span class="tag-good">CPU 배분 제어력이 크며, </span>
          시스템 정책에 따라 우선순위를 자유롭게 조정 가능
        </td>
        <td>
          낮은 우선순위 프로세스는 장기간 실행되지 않는 <span class="tag-bad">심각한 기아 현상이 발생하며,</span>
          기아 방지를 위해 에이징과 같은 보완 기법이 필요
        </td>
      </tr>

      <tr>
        <td class="alg-col-name">Round Robin</td>
        <td>
          <span class="tag preempt">Preemptive</span>
        </td>
        <td>
          정해진 Time Quantum만큼 돌아가며 CPU를 나눠쓰는 방식
        </td>
        <td>
          <span class="tag">Time Quantum 값</span>
        </td>
        <td>
          Time Quantum 덕분에 <span class="tag-good">응답성</span>이 좋으며, 인터랙티브 시스템에 적합
          또한, 모든 프로세스가 CPU를 조금씩 가져가는 공정한 구조
        </td>
        <td>
          Quantum이 너무 짧을 땐 <span class="tag-warn">Context Switching 비용이 증가</span>하고, 너무 길 땐 <span class="tag-warn">응답성이 저하</span>되므로
          적절한 Quantum 선택이 핵심
        </td>
      </tr>
      </tbody>
    </table>
  </section>

  <!-- 하단: 직접 비교 -->
  <h2 class="section-title">직접 비교하기</h2>
  <p class="section-desc">
    프로세스의 종류를 선택하고, 비교하고 싶은 알고리즘을 선택해 두 알고리즘을 직관적으로 비교할 수 있습니다.
  </p>

  <div class="panel" style="margin-bottom:0">
    <div class="scenario-row">
      <div class="scenario-row-left">
        <strong> 예시 시나리오 선택 - - - - - </strong>
      </div>
      <div>
        <select name="scenario" id="scenario-select">
          <option value="A">Preset A – 모든 프로세스 동시에 도착</option>
          <option value="B">Preset B – 도착 시간이 서로 다른 4개 프로세스</option>
          <option value="C">Preset C – 기아 가능성이 있는 Priority 상황</option>
        </select>
      </div>
    </div>

    <div class="compare-grid">
      <!-- 왼쪽 알고리즘 -->
      <div class="compare-card">
        <div class="compare-header">
          <div>
            <div class="compare-title">선택 알고리즘 - 1</div>
          </div>
          <div>
            <div class="mini-label">알고리즘 선택</div>
            <select name="alg1" id="alg1-select">
              <option value="FCFS">FCFS</option>
              <option value="SJF">SJF</option>
              <option value="PRIORITY">Priority</option>
              <option value="RR">Round Robin</option>
            </select>
          </div>
        </div>

        <div>
          <div class="mini-label">핵심 지표 (예: 선택된 시나리오 기준)</div>
          <table class="metric-table">
            <tr>
              <th>평균 대기 시간 (WT)</th>
              <td id="alg1-wt" class="placeholder">결과를 실행하면 표시됩니다</td>
            </tr>
            <tr>
              <th>평균 반환 시간 (TAT)</th>
              <td id="alg1-tat" class="placeholder">-</td>
            </tr>
            <tr>
              <th>평균 응답 시간 (RT)</th>
              <td id="alg1-rt" class="placeholder">-</td>
            </tr>
            <tr>
              <th>Throughput</th>
              <td id="alg1-throughput" class="placeholder">-</td>
            </tr>
            <tr>
              <th>Starvation</th>
              <td id="alg1-starvation" class="placeholder">-</td>
            </tr>
          </table>
        </div>

        <div>
          <div class="mini-label">Gantt Chart</div>
          <div class="gantt-box" id="alg1-gantt">
            비교 실행 후 간트 차트 요약이 표시됩니다.
          </div>
        </div>
      </div>

      <!-- 오른쪽 알고리즘 -->
      <div class="compare-card">
        <div class="compare-header">
          <div>
            <div class="compare-title">선택 알고리즘 - 2</div>
            <div class="compare-meta">오른쪽에 선택된 알고리즘의 결과</div>
          </div>
          <div>
            <div class="mini-label">알고리즘 선택</div>
            <select name="alg2" id="alg2-select">
              <option value="FCFS">FCFS</option>
              <option value="SJF">SJF</option>
              <option value="PRIORITY">Priority</option>
              <option value="RR">Round Robin</option>
            </select>
          </div>
        </div>

        <div>
          <div class="mini-label">핵심 지표 (예: 선택된 시나리오 기준)</div>
          <table class="metric-table">
            <tr>
              <th>평균 대기 시간 (WT)</th>
              <td id="alg2-wt" class="placeholder">결과를 실행하면 표시됩니다</td>
            </tr>
            <tr>
              <th>평균 반환 시간 (TAT)</th>
              <td id="alg2-tat" class="placeholder">-</td>
            </tr>
            <tr>
              <th>평균 응답 시간 (RT)</th>
              <td id="alg2-rt" class="placeholder">-</td>
            </tr>
            <tr>
              <th>Throughput</th>
              <td id="alg2-throughput" class="placeholder">-</td>
            </tr>
            <tr>
              <th>Starvation</th>
              <td id="alg2-starvation" class="placeholder">-</td>
            </tr>
          </table>
        </div>

        <div>
          <div class="mini-label">Gantt Chart</div>
          <div class="gantt-box" id="alg2-gantt">
            비교 실행 후 간트 차트 요약이 표시됩니다.
          </div>
        </div>
      </div>
    </div>

    <div class="comment-panel" id="insight-panel">
      <strong>Comparison Insight</strong><br/><br>
      <span id="insight-text">
        알고리즘 비교 후 동일한 조건에서 왜 서로 다른 실행 흐름과 성능을 보이는지 설명합니다.
      </span>
    </div>

    <div class="btn-row">
      <button type="button" class="btn" id="run-compare-scheduling-btn">
        비교 실행
      </button>
      <button type="button" class="btn" id="save-compare-scheduling-btn">
        비교 결과 저장하기
      </button>
    </div>
  </div>
</main>

<script>
  // --- 로그인 / 프로필 버튼 + 버튼 이벤트 등록 ---
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('authArea');
    if (container) {
      const user = sessionStorage.getItem('user');
      container.innerHTML = (user && user.trim() !== '')
        ? `
        <button class="profile-btn" aria-label="My Page" title="My Page" onclick="location.href='mypage.html'">
          <svg viewBox="0 0 24 24" fill="black" xmlns="http://www.w3.org/2000/svg">
            <circle cx="12" cy="8" r="4"></circle>
            <path d="M4 20c0-4 4-6 8-6s8 2 8 6"></path>
          </svg>
        </button>`
        : `<button class="login-btn" onclick="location.href='login.html'">Login</button>`;
    }

    const saveBtn = document.getElementById('save-compare-scheduling-btn');
    if (saveBtn) {
      saveBtn.addEventListener('click', saveCompareSchedulingRecord);
    }

    const runBtn = document.getElementById('run-compare-scheduling-btn');
    if (runBtn) {
      runBtn.addEventListener('click', runCompareScheduling);
    }
  });

  // --- Preset 시나리오 정의 ---
  function getPresetProcesses(scenarioId) {
    // SchedulingReq.Proc 형식: { pid, arrival, burst }
    switch (scenarioId) {
      case 'A':
        return [
          { pid: 'P1', arrival: 0, burst: 5 },
          { pid: 'P2', arrival: 0, burst: 3 },
          { pid: 'P3', arrival: 0, burst: 8 },
          { pid: 'P4', arrival: 0, burst: 6 }
        ];
      case 'B':
        return [
          { pid: 'P1', arrival: 0,  burst: 10 },
          { pid: 'P2', arrival: 3,  burst: 4 },
          { pid: 'P3', arrival: 5,  burst: 2 },
          { pid: 'P4', arrival: 9,  burst: 6 }
        ];
      case 'C':
        return [
          { pid: 'P1', arrival: 0,  burst: 12 },
          { pid: 'P2', arrival: 1,  burst: 3 },
          { pid: 'P3', arrival: 2,  burst: 2 },
          { pid: 'P4', arrival: 4,  burst: 1 }
        ];
      default:
        return [];
    }
  }

  // --- /api/sim/scheduling 호출 ---
  async function requestScheduling(algo, processes) {
    const body = {
      algo: algo,
      quantum: null,   // RR이 아닌 경우에는 null, 백엔드에서 기본 처리
      processes: processes
    };

    const res = await fetch('/api/sim/scheduling', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      throw new Error('서버 오류: ' + res.status);
    }
    return await res.json(); // { gantt: [...], metrics: {...} }
  }

  // --- Throughput 계산 (간단 버전: 프로세스 수 / 마지막 종료 시간) ---
  function calcThroughput(gantt, procCount) {
    if (!gantt || gantt.length === 0) return '-';
    const last = gantt[gantt.length - 1];
    const totalTime = last.end;
    if (!totalTime || totalTime <= 0) return '-';
    return (procCount / totalTime).toFixed(3) + ' proc / unit';
  }

  // --- Starvation 설명 텍스트 (알고리즘 이름 기준) ---
  function getStarvationText(algo) {
    const upper = (algo || '').toUpperCase();
    if (upper === 'FCFS' || upper === 'RR') {
      return '시나리오 기준, 기아 가능성 낮음';
    }
    if (upper === 'SJF' || upper === 'PRIORITY') {
      return '긴 작업 / 낮은 우선순위 작업의 기아 가능성 있음';
    }
    return '-';
  }

  // --- Gantt 요약 문자열 만들기 ---
  function formatGantt(gantt) {
    if (!gantt || gantt.length === 0) {
      return '시뮬레이션 결과가 없습니다.';
    }
    return gantt
      .map(seg => `${seg.pid} [${seg.start}~${seg.end}]`)
      .join('  →  ');
  }

  // --- 왼쪽/오른쪽 카드에 결과 렌더링 ---
  function renderAlgResult(side, algo, data, procCount) {
    const metrics = data.metrics || {};
    const gantt = data.gantt || [];

    const prefix = side === 'left' ? 'alg1' : 'alg2';

    const wtEl = document.getElementById(prefix + '-wt');
    const tatEl = document.getElementById(prefix + '-tat');
    const rtEl = document.getElementById(prefix + '-rt');
    const thEl = document.getElementById(prefix + '-throughput');
    const stEl = document.getElementById(prefix + '-starvation');
    const gEl = document.getElementById(prefix + '-gantt');

    if (!wtEl || !tatEl || !rtEl || !thEl || !stEl || !gEl) return;

    wtEl.textContent = (metrics.avgWaiting ?? '-');
    tatEl.textContent = (metrics.avgTurnaround ?? '-');
    rtEl.textContent = (metrics.avgResponse ?? '-');
    thEl.textContent = calcThroughput(gantt, procCount);
    stEl.textContent = getStarvationText(algo);
    gEl.textContent = formatGantt(gantt);

    wtEl.classList.remove('placeholder');
    tatEl.classList.remove('placeholder');
    rtEl.classList.remove('placeholder');
    thEl.classList.remove('placeholder');
    stEl.classList.remove('placeholder');
  }

  // ========================
  //   코멘트(Comparison Insight) 로직
  // ========================

  // 알고리즘 쌍을 정규화해서 key 만들기 (순서 상관 X)
  function makePairKey(a, b) {
    const arr = [(a || '').toUpperCase(), (b || '').toUpperCase()].sort();
    return arr.join('-');
  }

  // 1) 기본 코멘트 (시나리오와 무관한 구조적 차이)
  const baseCommentMap = {
    'FCFS-SJF':
      'SJF는 CPU burst가 짧은 작업을 먼저 실행해서 평균 대기·반환 시간이 유리한 대신, 긴 작업이 계속 뒤로 밀려 기아 위험이 생깁니다. FCFS는 도착 순서만 따르기 때문에 구현이 단순하고 기아는 없지만, 긴 작업 하나 때문에 뒤에 온 짧은 작업들이 오래 묶이는 Convoy effect가 자주 발생합니다.',
    'FCFS-RR':
      'RR은 Time Quantum 단위로 모든 프로세스에게 CPU를 조금씩 돌려 줘서 응답성이 좋고 공정하지만, Context Switching 오버헤드가 늘어날 수 있습니다. FCFS는 한 번 CPU를 잡으면 끝까지 쓰는 대신 뒤에 있는 작업은 처음부터 끝까지 기다려야 해서 응답 시간 면에서 불리하지만, 오버헤드는 거의 없습니다.',
    'FCFS-PRIORITY':
      'Priority는 우선순위가 높은 작업에 CPU를 먼저 배분해 중요 작업을 빠르게 처리할 수 있지만, 우선순위가 낮은 작업은 오랫동안 실행되지 않는 기아가 쉽게 생길 수 있습니다. FCFS는 정책 제어력은 없지만 도착 순서대로만 처리하기 때문에, 적어도 모든 작업이 언젠가는 실행된다는 점에서 기아는 발생하지 않습니다.',
    'RR-SJF':
      'SJF는 짧은 작업을 우선 처리해 평균 대기·반환 시간을 최소화하는 데 강점이 있지만, 긴 작업은 계속 뒤로 밀려 기아에 취약합니다. RR은 burst 길과 상관 없이 모든 작업이 Time Quantum마다 조금씩 CPU를 가져가 공정하고 응답성이 좋지만, 평균 시간 지표는 SJF보다 나쁜 경우가 많습니다.',
    'PRIORITY-SJF':
      'SJF는 CPU burst 길이를 기준으로 짧은 작업을 먼저 실행하고, Priority는 우선순위 값을 기준으로 중요한 작업을 먼저 실행합니다. 둘 다 특정 작업을 우대하는 편향이 있지만, Priority는 중요하지만 긴 작업도 먼저 처리할 수 있고, SJF는 짧은 작업 위주로 평균 성능을 끌어올리는 대신 긴 작업이 계속 뒤로 밀릴 수 있다는 점에서 차이가 있습니다.',
    'PRIORITY-RR':
      'RR은 우선순위를 고려하지 않고 모든 작업에 CPU를 균등하게 나누어 주기 때문에 기아가 거의 없고, 인터랙티브 환경에서 응답성이 좋습니다. Priority는 중요한 작업에 CPU를 몰아 줄 수 있는 대신 우선순위가 낮은 작업은 사실상 실행되지 않는 기아가 쉽게 생길 수 있습니다. 즉 RR은 공정성과 응답성, Priority는 중요도 반영과 정책 제어력에 초점을 둔 구조입니다.'
  };

  // 2) 시나리오별 강조 포인트
  const scenarioCommentMap = {
    'A': { // 동시 도착
      'FCFS-SJF':
        'Preset A에서는 모든 프로세스가 동시에 도착하므로, 도착 순서와 상관 없이 버스트 길이로만 순서를 정하는 SJF의 장점이 가장 또렷하게 보입니다. SJF 쪽에서 평균 대기·반환 시간이 크게 줄어드는 대신, 가장 긴 작업 하나는 거의 끝까지 밀려 대기 시간이 크게 늘어나는 패턴을 확인할 수 있습니다.',
      'FCFS-RR':
        'Preset A에서 긴 작업이 섞여 있을 때 FCFS는 긴 작업이 앞에 오면 뒤에 있는 모든 작업이 한 번에 묶여 기다리는 Convoy 패턴이 나타납니다. RR은 긴 작업도 잘게 쪼개서 돌려 주기 때문에 모든 프로세스가 초반에 한 번씩 CPU를 잡는 대신, 전체 완료 시간은 약간 늘어날 수 있습니다.',
      'FCFS-PRIORITY':
        'Preset A에서는 Priority가 모든 프로세스가 동시에 줄 서 있는 상태에서 우선순위가 높은 작업을 먼저 몰아서 처리하는 모습이 뚜렷하게 드러납니다. 같은 입력에서 FCFS는 우선순위를 완전히 무시하고 도착 순서대로만 처리하기 때문에, 중요하지만 늦게 도착한 작업이 뒤로 밀려 있는 대비를 볼 수 있습니다.',
      'RR-SJF':
        'Preset A에서는 짧은 작업 비중이 클수록 SJF가 평균 대기·반환 시간에서 RR을 크게 이기는 경향이 있습니다. 반대로 RR은 모든 작업이 초반에 한 번씩 CPU를 받기 때문에, 평균 지표에서는 손해를 보더라도 “모두가 조금씩 돌아간다”는 공정성이 잘 드러납니다.',
      'PRIORITY-SJF':
        'Preset A에서 Priority의 우선순위 설정이 burst 길이와 얼마나 일치하느냐에 따라, 결과가 SJF와 비슷해지기도 하고 완전히 달라지기도 합니다. 짧은 작업에 높은 priority를 주면 두 알고리즘이 유사하게 보이고, 긴 작업에 높은 priority를 주면 Priority 쪽이 SJF와 정반대의 순서를 만들어 냅니다.',
      'PRIORITY-RR':
        'Preset A에서는 RR이 모든 프로세스에 균등하게 CPU를 나눠 주는 반면, Priority는 높은 우선순위 작업을 먼저 몰아서 끝내는 패턴이 뚜렷하게 나타납니다. 같은 시나리오에서도 RR은 “모두가 조금씩 나아가는 그림”, Priority는 “몇 개의 중요한 작업이 먼저 다 끝나는 그림”으로 대비됩니다.'
    },
    'B': { // 도착 시간 서로 다름
      'FCFS-SJF':
        'Preset B처럼 도착 시간이 엇갈리는 상황에서는, FCFS가 먼저 도착한 긴 작업을 오래 실행하는 동안 나중에 온 짧은 작업이 뒤에서 줄만 서 있는 반면, SJF는 나중에 도착했더라도 더 짧은 작업이면 앞에 끼어들어 먼저 실행되는 차이가 뚜렷하게 나타납니다.',
      'FCFS-RR':
        'Preset B에서는 긴 작업이 먼저 도착하고 짧은 작업이 나중에 들어올 때, FCFS는 긴 작업이 끝날 때까지 뒤에 온 작업이 전혀 실행 기회를 못 받는 경우가 생깁니다. RR은 긴 작업이 돌고 있는 동안에도 나중에 온 작업들이 time slice마다 조금씩 CPU를 받기 때문에, 응답 시간과 공정성 측면에서 차이가 크게 벌어집니다.',
      'FCFS-PRIORITY':
        'Preset B처럼 도착 시간이 섞여 있을 때 Priority는 중요한 작업이 늦게 도착해도 도착 시점부터 기존 낮은 우선순위 작업보다 먼저 CPU를 뺏어 올 수 있습니다. 같은 상황에서도 FCFS는 도착 순서만 보기 때문에, 중요한 작업이 나중에 오면 실제 중요도와 상관 없이 뒤에서 오래 기다리게 됩니다.',
      'RR-SJF':
        'Preset B에서는 새로 도착하는 짧은 작업이 있을 때, SJF는 기존의 긴 작업을 계속 뒤로 밀어 내고 짧은 작업부터 처리해 평균 대기·반환 시간을 낮춥니다. RR은 도착한 순서대로 큐에 들어간 뒤 time slice로 돌기 때문에 완전히 “짧은 작업 우선”이 되지는 않지만, 대신 모든 작업이 비교적 빠르게 첫 실행 기회를 얻는 공정성이 유지됩니다.',
      'PRIORITY-SJF':
        'Preset B에서는 도착 시간이 섞이면서, 짧으면서 우선순위도 높은 작업은 두 알고리즘 모두 빠르게 처리하지만, 짧지만 우선순위가 낮거나 길지만 우선순위가 매우 높은 작업에서는 두 알고리즘의 실행 순서가 크게 갈립니다. 같은 시나리오에서도 “burst 기준 편향(SJF)”과 “우선순위 기준 편향(Priority)”의 차이가 명확해집니다.',
      'PRIORITY-RR':
        'Preset B에서 새로 도착하는 작업이 많을수록, RR은 도착만 하면 곧 한 번씩 CPU를 맛보게 되는 반면 Priority는 낮은 우선순위 작업이 계속 뒤로 밀려 실행 기회를 거의 얻지 못하는 상황이 자주 생깁니다. 사용자 입장에서는 RR 쪽이 “일단 한 번이라도 돌아갔다”는 응답성이 훨씬 잘 느껴집니다.'
    },
    'C': { // Priority 기아 상황
      'FCFS-SJF':
        'Preset C는 priority 기반 기아 상황을 보여 주기 위한 시나리오지만, 같은 입력에서도 SJF는 긴 작업을 끝까지 뒤로 미루면서 또 다른 형태의 기아를 만드는 반면 FCFS는 도착 순서만 따르기 때문에 일찍 도착한 긴 작업이라면 언젠가는 실행되는 단순한 공정성을 보여 줍니다.',
      'FCFS-PRIORITY':
        'Preset C에서는 Priority가 낮은 우선순위 프로세스를 거의 실행하지 않는 전형적인 기아 예시로 동작하도록 구성되어 있습니다. 같은 입력에서 FCFS는 우선순위를 전혀 고려하지 않고 도착 순서대로 처리하기 때문에, “기아가 발생하는 Priority”와 “기아가 없는 FCFS”의 대비가 가장 극적으로 드러납니다.',
      'RR-SJF':
        'Preset C에서도 SJF는 짧은 작업 위주로 CPU를 배분하면서 길게 돌아야 하는 작업을 계속 뒤로 밀어 기아 위험을 만듭니다. RR은 같은 입력에서도 모든 프로세스가 Time Quantum마다 CPU를 조금씩 가져가도록 보장해, 우선순위를 쓰지 않아도 기아 없이 모두가 조금씩 앞으로 나아가는 패턴을 보여 줍니다.',
      'PRIORITY-SJF':
        'Preset C에서는 Priority가 우선순위가 낮은 프로세스를 거의 실행하지 않는 반면, SJF는 burst가 긴 프로세스를 계속 뒤로 미루는 다른 형태의 기아를 만들어 냅니다. 둘 다 기아 위험이 있지만 Priority는 “우선순위 값”, SJF는 “CPU burst 길이”를 기준으로 프로세스를 희생시키는 구조라는 차이를 확인할 수 있습니다.',
      'PRIORITY-RR':
        'Preset C에서는 Priority가 낮은 우선순위/긴 작업을 거의 실행하지 않는 전형적인 starvation 사례를 만들고, 같은 입력을 RR로 돌리면 모든 프로세스가 주기적으로 CPU를 받으며 조금씩이라도 진행됩니다. 같은 시나리오에서 Priority는 중요 작업 몇 개에 CPU가 집중되고, RR은 우선순위를 무시하더라도 기아 없이 공정하게 나누어 주는 모습을 비교할 수 있습니다.'
    }
  };

  function getSchedulingComment(alg1, alg2, scenarioId) {
    const upperA = (alg1 || '').toUpperCase();
    const upperB = (alg2 || '').toUpperCase();

    // 같은 알고리즘 선택했을 때 코멘트
    if (upperA === upperB && upperA) {
      return `두 카드 모두 <b>${upperA}</b> 알고리즘을 선택했습니다.<br/>
같은 프로세스 집합과 시나리오에서는 간트 차트와 평균 지표가 거의 동일하게 나오는 것이 정상이며,<br/>
이 화면은 특정 알고리즘의 <b>절대적인 성능</b>을 확인하는 용도로 사용할 수 있습니다.`;
    }

    const pairKey = makePairKey(alg1, alg2);
    const base = baseCommentMap[pairKey];
    const scenarioMap = scenarioCommentMap[scenarioId];
    const scenarioComment = scenarioMap ? scenarioMap[pairKey] : null;

    if (!base && !scenarioComment) {
      return null;
    }
    if (!scenarioComment) {
      return base;
    }
    if (!base) {
      return scenarioComment;
    }
    // 둘 다 있으면 기본 코멘트 + 줄바꿈 + 시나리오 강조
    return base + '<br/><br/>' + scenarioComment;
  }

  function updateSchedulingComment(alg1, alg2, scenarioId) {
    const insightSpan = document.getElementById('insight-text');
    if (!insightSpan) return;

    const comment = getSchedulingComment(alg1, alg2, scenarioId);
    if (!comment) {
      insightSpan.innerHTML =
        '알고리즘 비교 후 동일한 조건에서 왜 서로 다른 실행 흐름과 성능을 보이는지 설명합니다.';
      return;
    }
    insightSpan.innerHTML = comment;
  }

  // --- “비교 실행” 버튼 로직 ---
  async function runCompareScheduling() {
    const scenarioSelect = document.getElementById('scenario-select');
    const alg1Select = document.getElementById('alg1-select');
    const alg2Select = document.getElementById('alg2-select');

    if (!scenarioSelect || !alg1Select || !alg2Select) {
      alert('선택 정보를 읽어올 수 없습니다.');
      return;
    }

    const scenarioId = scenarioSelect.value;
    const processes = getPresetProcesses(scenarioId);

    if (!processes || processes.length === 0) {
      alert('선택된 시나리오에 프로세스 정보가 없습니다.');
      return;
    }

    const alg1 = alg1Select.value;
    const alg2 = alg2Select.value;

    try {
      // 두 알고리즘을 같은 시나리오로 병렬 실행
      const [res1, res2] = await Promise.all([
        requestScheduling(alg1, processes),
        requestScheduling(alg2, processes)
      ]);

      renderAlgResult('left', alg1, res1, processes.length);
      renderAlgResult('right', alg2, res2, processes.length);

      // 코멘트 영역 업데이트 (Comparison Insight)
      updateSchedulingComment(alg1, alg2, scenarioId);
    } catch (e) {
      console.error(e);
      alert('비교 실행 중 오류가 발생했습니다.');
    }
  }

  // --- 비교 결과 저장 함수 ---
  async function saveCompareSchedulingRecord() {
    const scenarioSelect = document.getElementById('scenario-select');
    const alg1Select = document.getElementById('alg1-select');
    const alg2Select = document.getElementById('alg2-select');

    if (!scenarioSelect || !alg1Select || !alg2Select) {
      alert('선택 정보를 읽어올 수 없습니다.');
      return;
    }

    const scenario = scenarioSelect.value;
    const scenarioLabel = scenarioSelect.options[scenarioSelect.selectedIndex].text;

    const alg1 = alg1Select.value;
    const alg1Label = alg1Select.options[alg1Select.selectedIndex].text;

    const alg2 = alg2Select.value;
    const alg2Label = alg2Select.options[alg2Select.selectedIndex].text;

    const insightSpan = document.getElementById('insight-text');
    const insightText = insightSpan ? insightSpan.innerText : '';

    const payload = {
      type: 'compare-scheduling',
      title: `CPU Scheduling 비교 (${alg1Label} vs ${alg2Label})`,
      scenario,
      scenarioLabel,
      alg1,
      alg1Label,
      alg2,
      alg2Label,
      insight: insightText
      // 나중에 지표/간트차트까지 저장하고 싶으면 여기 필드를 확장하면 됨
    };

    try {
      const res = await fetch('/api/records', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        throw new Error('status ' + res.status);
      }

      alert('저장하였습니다. 마이페이지에서 확인하세요.');
    } catch (e) {
      console.error(e);
      alert('저장 중 오류가 발생했습니다.');
    }
  }
</script>

</body>
</html>

